Q1: Write code to remove duplicates form an unsorted linked list.
How would your solve this problem if a temporary buffer is not allowed?

Q2: Implement an algorithm to find the kth to last element of a singly linked list.

Q3: Implement an algorithm to delete a node in the middle of a singly link list, given only access to that node.
Eg: Input: the node c from the linked list a->b->c->d->e
	Result:nothing is returned, but the new linked list look like a->b->d->e
	
Q4: Write code to partition a linked list around a value x, such that all nodes less than x come before all node greater than or equal to x.

Q5: You have two numbers represented by a linked list, where each node contains a single digit. The digits are stored in reverse order, such that the 1's digit is at the head of the list. Write a function that adds the two numbers and returns the sum as a linked list.
Eg: Input:(7->1->6)+(5->9->2). That is, 617+295.
	Output:(2->1->9). That is 912.
Suppose the digits are stored in forward order. Repeat the above problem.
Eg: Input:(6->1->7)+(2->9->5). That is, 617+295.
	Output:(9->1->2). That is 912.
	
Q6: Given a circular linked list, implement an algorithm which returns the node at the beginning of the loop.
Def: Circular linked list: A (corrupt) linked list in which a node's next pointer points to an earlier node, so as to mank a loop in the linked list.
Eg: Input: A->B->C->D->E->C
	Output: C
	
Q7: Implement a function to check if a linked list is a palindrome.